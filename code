
import datetime
import threading
import time
import tkinter as tk
import pygetwindow as gw
import pickle
import os
import matplotlib.pyplot as plt
import pystray._win32
from plyer import notification
import customtkinter
from PIL import Image
colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
          '#FFA500', '#800080', '#A52A2A', '#FFC0CB', '#808000', '#008000',
          '#008080', '#4682B4', '#D2691E', '#CD5C5C', '#E9967A', '#F08080',
          '#FA8072', '#DA70D6', '#C71585', '#DB7093', '#FF69B4', '#FF1493',
          '#9400D3', '#8A2BE2', '#4B0082', '#483D8B', '#6A5ACD', '#7B68EE',
          '#8FBC8F', '#90EE90', '#3CB371', '#2E8B57', '#ADFF2F', '#7FFF00',
          '#7CFC00', '#B0E2FF', '#87CEFA', '#87CEEB', '#1E90FF', '#6495ED',
          '#4169E1', '#00BFFF', '#5F9EA0', '#ADD8E6', '#B0C4DE', '#F0F8FF',
          '#FFD700', '#EEE8AA', '#F5DEB3']
#⚠️
is_empty = os.stat('time_data.txt').st_size == 0
current_date = datetime.date.today().strftime("%d.%m.%Y")
str_date = current_date
selected_date = datetime.datetime.strptime(str_date, '%d.%m.%Y').date()
str_date = selected_date.strftime('%d.%m.%Y')


background_color = '#19080f'
color_text = '#F1E0C2'
button_bg_col = '#fee6df'
button_text_col = '#4C1E0B'
button_corner_radius = 10
if is_empty:
    apps = {str(current_date):{}}
else:
    with open('time_data.txt', 'rb') as f:
        apps = pickle.load(f)

    if str(current_date) not in apps:
        apps[str(current_date)] = {}

update_value = 10
sum_sec = 0
icon = Image.open('icon.png')
if str(current_date) in apps:
    sum_sec = sum(apps[str(current_date)].values())
else:
    sum_sec = 0
limit = float('inf')
is_warning_showed = False

def show_warning(title, message, timeout):
    global is_warning_showed
    if message == 'Нет данных':
        notification.notify(
            title=title,
            message=message,
            toast=True,
            timeout=timeout
        )
    elif is_warning_showed == False:
        notification.notify(
            title=title,
            message=message,
            toast=True,
            timeout=timeout
        )
        is_warning_showed = True
statistic_opened = False
statistic_window = None
tray_icon = None
def exit_app():
    global tray_icon
    tray_icon.stop()
    root.destroy()
    os._exit(0)
def show_window():
    global root
    if root:
        root.deiconify()
        if tray_icon:
            tray_icon.stop()

fig = None
def close_window():
    global tray_icon, fig

    if fig != None:
        plt.close(fig)

    if root:
        root.withdraw()
        menu = pystray.Menu(pystray.MenuItem("Выход", exit_app),
                            pystray.MenuItem(text="Показать", action=show_window, default=True))
        def draw_tray_icon():
            global tray_icon
            tray_icon = pystray.Icon('name', icon, 'timer_apps', menu=menu, on_click=show_window)
            tray_icon.run()
        tray_thread = threading.Thread(target = draw_tray_icon)
        tray_thread.daemon = True
        tray_thread.start()
def update_date_label():
    global str_date, selected_date
    data_label.config(text=selected_date.strftime('%d.%m.%Y'))
    str_date = selected_date.strftime('%d.%m.%Y')
def date_today():

    global selected_date
    selected_date = datetime.datetime.strptime(current_date, '%d.%m.%Y')
    update_date_label()
def month_forward():
    global selected_date  # Объявляем, что используем глобальную переменную
    selected_date += datetime.timedelta(days=30)
    update_date_label()
def month_back():
    global selected_date  # Объявляем, что используем глобальную переменную
    selected_date -= datetime.timedelta(days=30)
    update_date_label()
def week_forward():
    global selected_date  # Объявляем, что используем глобальную переменную
    selected_date += datetime.timedelta(days = 7)
    update_date_label()
def week_back():
    global selected_date  # Объявляем, что используем глобальную переменную
    selected_date -= datetime.timedelta(days = 7)
    update_date_label()
def date_forward():
    global selected_date  # Объявляем, что используем глобальную переменную
    selected_date += datetime.timedelta(days = 1)
    update_date_label()
def date_back():
    global selected_date  # Объявляем, что используем глобальную переменную

    selected_date -= datetime.timedelta(days=1)
    update_date_label()
def on_close(event):
    global statistic_opened
    statistic_opened = False

def save_data():
    with open('time_data.txt', 'wb') as f:
        global apps
        pickle.dump(apps, f)

def show_statistic(statistic_data, legend_title, statistic_title):
    global statistic_opened, fig, ax, legend_obj
    for leg in statistic_data.keys():
        hr = str((statistic_data[leg]) // 3600)
        min = str((statistic_data[leg]) // 60).zfill(2)
        sec = str(statistic_data[leg] - int(min) * 60).zfill(2)
        legend_title.append(str(hr + ':' + min + ':' + sec + ' ' + leg))
    if not statistic_opened:
        statistic_opened = True
        # Создаем фигуру и оси только при первом вызове
        fig, ax = plt.subplots(figsize=(8, 6))
        fig.subplots_adjust(left=0.2)  # Освобождаем место для легенды
        # Настройка круговой диаграммы
        wedges, texts, autotexts = ax.pie(
            statistic_data.values(),
            pctdistance=1.1,
            autopct='%1.1f%%',
            startangle=90,
            radius=0.5,
            counterclock=False,
            colors=colors,
            center=(-0.4, 0.5)  # Смещаем центр влево
        )
        # Сохраняем объект легенды для последующего обновления
        legend_obj = ax.legend(
            wedges,
            legend_title,
            loc="center left",
            bbox_to_anchor=(0.8, 0.5)
        )
        # Настраиваем оси для касания левого края
        ax.set_aspect('equal')
        ax.set_xlim(-0.5, 0.5)
        ax.set_ylim(0, 1.1)
        ax.text(0, 1.1, statistic_title, family='fantasy', ha='center', va='top', fontsize=14)
        plt.show(block=False)  # Не блокируем выполнение кода
        fig.canvas.mpl_connect('close_event', on_close)
    else:
        # Обновляем данные на существующей фигуре
        ax.clear()
        # Перерисовываем диаграмму с новыми данными
        wedges, texts, autotexts = ax.pie(
            statistic_data.values(),
            pctdistance=1.1,
            autopct='%1.1f%%',
            startangle=90,
            radius=0.5,
            counterclock=False,
            colors=colors,
            center=(-0.4, 0.5)  # Смещаем центр влево
        )
        # Обновляем легенду
        if legend_obj:
            legend_obj.remove()  # Удаляем старую легенду
            legend_obj = ax.legend(
                wedges,
                legend_title,
                loc="center left",
                bbox_to_anchor=(0.8, 0.5)
            )
        # Восстанавливаем настройки осей
        ax.set_aspect('equal')
        ax.set_xlim(-0.5, 0.5)
        ax.set_ylim(0, 1.1)
        ax.text(0, 1.1, statistic_title, family='fantasy', ha='center', va='top', fontsize=14)
        fig.canvas.draw_idle()
        # Принудительное обновление графика
        fig.canvas.mpl_connect('close_event', on_close)

class Check_win:
    def __init__(self, root, info_label):

        self.root = root
        self.root.title("Timer_apps")
        self.update_interval = 1000  # Интервал обновления в миллисекундах
        self.track_active_window(info_label)  # Запускаем отслеживание
        self.data = str(limit - sum_sec)
        self.info_label = info_label
        self.track_time()
    def track_time(self):
        global current_date
        current_date = datetime.date.today().strftime('%d.%m.%Y')

        self.root.after(self.update_interval, self.track_time)
    def track_active_window(self, info_label):
        global sum_sec
        if sum_sec >= limit:
            show_warning('⚠️ПРЕДУПРЕЖДЕНИЕ⚠️', 'Вы превысили лимит времени за ПК!', 5)

        #try:

        active_window = gw.getActiveWindow()  # Получаем активное окно
        if active_window:
            title = active_window.title
        else:
            title = "None"
        if title in apps[str(current_date)]:
            apps[str(current_date)][title] += 1
            sum_sec += 1
        else:
            apps[str(current_date)][title] = 0
        sec_left = limit - sum_sec
        info_hrs = sec_left // 3600
        info_min = (sec_left - info_hrs * 3600) // 60
        save_data()
        info = str(info_hrs) + ':' + str(info_min).zfill(2)
        info_label.config(text = str(info))

        # except Exception as e:
        #     print(f"Error: {str(e)}")
        # Планируем следующее обновление
        self.root.after(self.update_interval, self.track_active_window, info_label)

def Show_limit(limit_time):
    #print(limit_time)
    global limit_minuts, limit_hours
    limit_hours = int(limit_time) // 60
    limit_minuts = int(limit_time) % 60
    text_scale.config(text=str(limit_hours) + ':' + str(limit_minuts).zfill(2))
def on_acceptbutton_pressed():
    global limit
    limit = limit_hours * 60 * 60 + limit_minuts * 60
    text_scale.destroy()
    accept_button.destroy()
    limit_time.destroy()
    info = limit - sum_sec
    info_label = tk.Label(text=str(info), font=("Small Fonts", 26), background = background_color, fg = color_text)
    info_label.grid(row = 0, column = 2, columnspan = 3, pady = 10)
    app = Check_win(root, info_label)


limit_hours = 0
limit_minuts = 30
day = None
week = None
month = None
list_date_opened = False

def calculating_range(days):
    dict_for_statistic = {}
    keys = list(apps.keys())
    start_week = (selected_date - datetime.timedelta(days=days)).strftime('%d.%m.%Y')

    start_week = datetime.datetime.strptime(start_week, '%d.%m.%Y').date()
    for_title = start_week.strftime('%d.%m.%Y')
    end_week = selected_date.strftime('%d.%m.%Y')
    taken_days = []
    for _ in range(days + 1):
        start_week_str = start_week.strftime('%d.%m.%Y')
        if start_week_str in keys:
            taken_days.append(start_week_str)
        start_week += datetime.timedelta(days=1)
    sum_week = 0
    if len(taken_days) != 0:
        for day in taken_days:
            for d in apps[day].items():
                name = d[0]
                value = d[1]
                if name in dict_for_statistic:
                    dict_for_statistic[name] += value
                else:
                    dict_for_statistic[name] = value
                sum_week += value
        delit_from_statistic = []
        for check in dict_for_statistic.items():
            if check[1] / sum_week < 0.03:
                delit_from_statistic.append(check[0])
        if days == 0:
            time_line_title = for_title
        else:
            time_line_title = for_title + '  -  ' + end_week
        for d in range(len(delit_from_statistic)):
            del dict_for_statistic[delit_from_statistic[d]]
        dict_for_statistic = dict(sorted(dict_for_statistic.items(), key=lambda item: item[1], reverse=True))
        show_statistic(dict_for_statistic, [], time_line_title)
    else:
        print('ошибка')
        show_warning('⚠️Ошибка⚠️', 'Нет данных', 1)
def statistic_for_month():
    calculating_range(30)
def statistic_for_week():
    calculating_range(7)
def statistic_for_day():
    calculating_range(0)
    # if str(selected_date) in apps:
    #     selected_dict = apps[str(selected_date)]
    #     sum_values = sum(selected_dict.values())
    #     statistic_data = {}
    #     for key in selected_dict.keys():
    #         if selected_dict[key] / sum_values >= 0.03:
    #             statistic_data[key] = selected_dict[key]
    #     legend_title = []
    #     statistic_data = dict(sorted(statistic_data.items(), key=lambda item: item[1], reverse=True))
    #     print(statistic_data)
    #     show_statistic(statistic_data, legend_title, selected_date)
    #
    # else:
    #     show_warning('⚠️Ошибка⚠️', 'Нет данных', 1)
def pick_time_intarval():
    global list_date_opened, day, week, month
    if list_date_opened == False:
        list_date_opened = True
        day = customtkinter.CTkButton(root, text = 'За день', corner_radius=button_corner_radius, command = statistic_for_day, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 110, height= 40, hover_color = '#D4FE81')
        week = customtkinter.CTkButton(root, text = 'За Неделю', corner_radius=button_corner_radius, command = statistic_for_week, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 110, height= 40, hover_color = '#D4FE81')
        month = customtkinter.CTkButton(root, text = 'За Mесец', corner_radius=button_corner_radius, command = statistic_for_month, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 110, height= 40, hover_color = '#D4FE81')
        day.grid(row=6, column=3, padx=5, pady=1)
        week.grid(row=7, column=3, padx=5, pady=1)
        month.grid(row=8, column=3, padx=5, pady=1)
    else:
        list_date_opened = False
        day.destroy()
        week.destroy()
        month.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry('600x600')
    root.configure(background = background_color)
    limit_time = tk.Scale(root, from_=30, to=360, width=20, troughcolor='#696969'
                                        ,showvalue=False, highlightthickness=0, sliderrelief='flat',
                                        bg = '#C0C0C0', activebackground='#D4FE81', sliderlength=50,
                                        orient=tk.HORIZONTAL,
                                        resolution=5, borderwidth=0, command=Show_limit)
    text_scale = tk.Label(text=str(limit_hours) + ':' + str(limit_minuts),  font=("Small Fonts", 26, 'bold'), fg = color_text, background = background_color)
    data_label = tk.Label(text = str(selected_date.strftime('%d.%m.%Y')), font = ("Small Fonts", 24), fg = color_text, background = background_color)
    accept_button = customtkinter.CTkButton(root, text = 'Подтвердить', corner_radius=button_corner_radius, command = on_acceptbutton_pressed, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 100, height= 35, hover_color = '#D4FE81')
    show_statistic_button = customtkinter.CTkButton(root, text = 'Показать статистику', corner_radius=button_corner_radius, command = pick_time_intarval, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 110, height= 40, hover_color = '#D4FE81')
    week_forward_button = customtkinter.CTkButton(root, text = '>>', corner_radius=35, command = week_forward, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col,width=40, height = 40, border_color = '#19080f',text_color = button_text_col, hover_color = '#D4FE81')
    week_back_button = customtkinter.CTkButton(root, text = '<<', corner_radius=35, command = week_back, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col,width=40, height = 40, border_color = '#19080f',text_color = button_text_col, hover_color = '#D4FE81')
    forward_button = customtkinter.CTkButton(root, text = '>', corner_radius=35, command = date_forward, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col,width=40, height = 40, border_color = '#19080f',text_color = button_text_col, hover_color = '#D4FE81')
    back_button = customtkinter.CTkButton(root, text = '<', corner_radius=35, command = date_back, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col,width=40, height = 40, border_color = '#19080f',text_color = button_text_col, hover_color = '#D4FE81')
    month_forward_button = customtkinter.CTkButton(root, text = '>>>', corner_radius=35, command = month_forward, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 40, height= 40, hover_color = '#D4FE81')
    month_back_button = customtkinter.CTkButton(root, text = '<<<', corner_radius=35, command = month_back, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 40, height= 40, hover_color = '#D4FE81')
    today_button = customtkinter.CTkButton(root, text = 'Сегодня', corner_radius=button_corner_radius, command = date_today, font = ("Avignon Pro", 13), border_width = 2, fg_color = button_bg_col, border_color = '#19080f',text_color = button_text_col, width = 100, height= 35, hover_color = '#D4FE81')


    root.columnconfigure(0, weight=1)
    root.columnconfigure(1, weight=1)
    root.columnconfigure(2, weight=1)
    root.columnconfigure(3, weight=1)
    root.columnconfigure(4, weight=1)
    root.columnconfigure(5, weight=1)
    root.columnconfigure(6, weight=1)



    text_scale.grid(row=0, column=2, columnspan=3, pady=3)
    limit_time.grid(row=1, column=0, columnspan=7, sticky="ew", padx=10, pady=10)
    accept_button.grid(row = 2, column=2, columnspan=3, pady=3)
    data_label.grid(row=3, column=2, columnspan=3, pady=3)
    today_button.grid(row=4, column=2, columnspan=3, pady=3)

    month_back_button.grid(row=5, column=0, padx=5, pady=10, sticky="e")
    week_back_button.grid(row=5, column=1, padx=5, pady=10, sticky="e")
    back_button.grid(row=5, column=2, padx=0, pady=10, sticky="e")
    show_statistic_button.grid(row=5, column=3, padx=5, pady=10)
    forward_button.grid(row=5, column=4, padx=0, pady=10, sticky = 'w')
    week_forward_button.grid(row=5, column=5, padx=0, pady=10, sticky = 'w')
    month_forward_button.grid(row=5, column=6, padx=0, pady=10, sticky = 'w')

    root.protocol("WM_DELETE_WINDOW", close_window)
    root.mainloop()

