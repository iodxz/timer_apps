import tkinter as tk
import pygetwindow as gw
import time as t
import pickle
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from plyer import notification
colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
              '#FFA500', '#800080', '#A52A2A', '#FFC0CB', '#808000', '#008000',
              '#008080', '#4682B4', '#D2691E', '#CD5C5C', '#E9967A', '#F08080',
              '#FA8072', '#DA70D6', '#C71585', '#DB7093', '#FF69B4', '#FF1493',
              '#9400D3', '#8A2BE2', '#4B0082', '#483D8B', '#6A5ACD', '#7B68EE',
              '#8FBC8F', '#90EE90', '#3CB371', '#2E8B57', '#ADFF2F', '#7FFF00',
              '#7CFC00', '#B0E2FF', '#87CEFA', '#87CEEB', '#1E90FF', '#6495ED',
              '#4169E1', '#00BFFF', '#5F9EA0', '#ADD8E6', '#B0C4DE', '#F0F8FF',
              '#FFD700', '#EEE8AA', '#F5DEB3']
#⚠️
is_empty = os.stat('time_data.txt').st_size == 0
if is_empty:
    apps = {}
else:
    with open('time_data.txt', 'rb') as f:
        apps = pickle.load(f)

update_value = 10
sum_sec = 0
for s in apps.values():
    sum_sec += s
limit = float('inf')

def show_warning(title, message):
    notification.notify(
        title=title,
        message=message,
        toast=True,
        timeout=5
    )
statistic_opened = False
statistic_window = None
def on_close(event):
    print("Окно закрыто")
    global statistic_opened
    statistic_opened = False
    print(statistic_opened)
def show_statistic():

    global statistic_opened, fig, ax, legend_obj

    if not statistic_opened:
        statistic_opened = True

        # Создаем фигуру и оси только при первом вызове
        fig, ax = plt.subplots(figsize=(8, 6))
        fig.subplots_adjust(left=0.2)  # Освобождаем место для легенды

        # Настройка круговой диаграммы
        wedges, texts, autotexts = ax.pie(
            apps.values(),
            pctdistance=0.9,
            autopct='%1.1f',
            startangle=90,
            radius=0.5,
            counterclock=False,
            colors=colors,
            center=(-0.4, 0.5)  # Смещаем центр влево
        )

        # Сохраняем объект легенды для последующего обновления
        legend_obj = ax.legend(
            wedges,
            apps.keys(),
            loc="center left",
            bbox_to_anchor=(0.8, 0.5)
        )

        # Настраиваем оси для касания левого края
        ax.set_aspect('equal')
        ax.set_xlim(-0.5, 0.5)
        ax.set_ylim(0, 1)
        plt.show(block=False)  # Не блокируем выполнение кода
        fig.canvas.mpl_connect('close_event', on_close)
    else:
        # Обновляем данные на существующей фигуре
        ax.clear()

        # Перерисовываем диаграмму с новыми данными
        wedges, texts, autotexts = ax.pie(
            apps.values(),
            pctdistance=0.9,
            autopct='%1.1f',
            startangle=90,
            radius=0.5,
            counterclock=False,
            colors=colors,
            center=(-0.4, 0.5)  # Смещаем центр влево
        )

        # Обновляем легенду
        if legend_obj:
            legend_obj.remove()  # Удаляем старую легенду
        legend_obj = ax.legend(
            wedges,
            apps.keys(),
            loc="center left",
            bbox_to_anchor=(0.8, 0.5)
        )

        # Восстанавливаем настройки осей
        ax.set_aspect('equal')
        ax.set_xlim(-0.5, 0.5)
        ax.set_ylim(0, 1)
        fig.canvas.draw_idle()
        # Принудительное обновление графика
        fig.canvas.mpl_connect('close_event', on_close)
    print('открыть статистику', statistic_opened)
class Check_win:
    def __init__(self, root, info_label):

        self.root = root
        self.root.title("Timer_apps")
        self.update_interval = 1000  # Интервал обновления в миллисекундах
        self.track_active_window(info_label)  # Запускаем отслеживание
        self.data = str(limit - sum_sec)
        self.info_label = info_label


    def track_active_window(self, info_label):
        global sum_sec
        if sum_sec >= limit:
            print(sum_sec, limit)
            show_warning('⚠️ПРЕДУПРЕЖДЕНИЕ⚠️', 'Вы превысили лимит времени за ПК!')
        #print(sum_sec)
        try:
            active_window = gw.getActiveWindow()  # Получаем активное окно
            if active_window:
                title = active_window.title
            else:
                title = "None"
            if title in apps:
                apps[title] += 1
                sum_sec += 1
            else:
                apps[title] = 0
            sec_left = limit - sum_sec
            info_hrs = sec_left // 3600
            info_min = (sec_left - info_hrs * 3600) // 60

            info = str(info_hrs) + ':' + str(info_min)
            info_label.config(text = str(info))
            with open('time_data.txt', 'wb') as f:
                pickle.dump(apps, f)


        except Exception as e:
            print(f"Error: {str(e)}")



        # Планируем следующее обновление
        self.root.after(self.update_interval, self.track_active_window, info_label)
limit_hours = 0
limit_minuts = 30
def Show_limit(limit_time):
    global limit_minuts, limit_hours
    limit_hours = int(limit_time) // 60
    limit_minuts = int(limit_time) % 60
    if limit_minuts == 0:
        text_scale.config(text=str(limit_hours) + ':' + str(limit_minuts) + '0')
    elif limit_minuts == 5:
        text_scale.config(text=str(limit_hours) + ':' + '0' + str(limit_minuts))
    else:
        text_scale.config(text=str(limit_hours) + ':' + str(limit_minuts))
def show_time():
    while True:

        info = limit - sum_sec
        print(info)
        info_label = tk.Label(text=str(info), font=("Arial", 22))
        info_label.config()
        t.sleep(1)

def on_acceptbutton_pressed():
    global limit

    limit = limit_hours * 60 * 60 + limit_minuts * 60
    text_scale.destroy()
    accept_button.destroy()
    limit_time.destroy()
    info = limit - sum_sec
    print(info)
    info_label = tk.Label(text=str(info), font=("Arial", 26))
    info_label.pack()

    app = Check_win(root, info_label)
    # show_time()


if __name__ == "__main__":
    root = tk.Tk()
    root.geometry('500x500')

    limit_time = tk.Scale(root, from_ = 30, to = 360,width = 20, troughcolor='#696969'
                          ,showvalue = False,highlightthickness=0,sliderrelief='flat',
                          bg='#D2B48C',activebackground='#C0C0C0',  sliderlength = 20, orient=tk.HORIZONTAL,
                          resolution=5, borderwidth=0, command = Show_limit)

    text_scale = tk.Label(text=str(limit_hours) + ':' + str(limit_minuts),  font=("Arial", 22))
    text_scale.pack(pady = 10)
    limit_time.pack(padx = 20, fill = 'x', pady = 0)
    accept_button = tk.Button(root, text = 'Подтвердить', command = on_acceptbutton_pressed)
    accept_button.pack(pady = 10)
    show_statistic_button = tk.Button(root, text = 'Показать статистику', command = show_statistic)
    show_statistic_button.pack()

    root.mainloop()

